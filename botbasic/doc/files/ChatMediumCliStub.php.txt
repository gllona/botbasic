<?php
/**
 * Medio de chat basado en el de Telegram donde la entrada viene de stdin y la salida va a stdout. Se ejecuta desde la línea de comandos
 *
 * @author      Gorka G LLona                               <gorka@gmail.com> <gorka@venicua.com>
 * @license     http://www.venicua.com/botbasic/license     Licencia de BotBasic
 * @see         http://www.venicua.com/botbasic             Referencia de BotBasic
 * @version     1.0 - 01.jan.2017
 * @since       0.1 - 01.jul.2016
 */



namespace botbasic;



/**
 * Clase ChatMediumCliStub
 *
 * Subclase de ChatMedium que implementa la comunicación con la herramienta CLI de simulación de interacciones.
 *
 * @package botbasic
 */
class ChatMediumCliStub extends ChatMedium
{



    /** @var string Archvo de salida para los updates generados como respuesta a los usos del CLI tool */
    static private $outFile = "/dev/stdout";

    /** @var array Mapa de bots definidos para esta chatapp, expresado como:
     *             [ bbCode-key-as-in-ChatMedium::$bbBots-for-default-bot    => [ botName, webHookScriptName, credential-for-chatapp-servers-API ],
     *               bbCode-key-as-in-ChatMedium::$bbBots-for-nondefault-bot => [...], ... ] */
    static private $cmBots = [
        // cliente
        10 => [ [ 'neuropowerbot',  '1000',      'TOK' ],
              ],
        // especialista channel 01 TO nn
        11 => [ [ 'np00bot',        '1100',      'TOK' ],
                [ 'np01bot',        '1101',      'TOK' ],
                [ 'np02bot',        '1102',      'TOK' ],
                [ 'np03bot',        '1103',      'TOK' ],
                [ 'np04bot',        '1104',      'TOK' ],
                [ 'np05bot',        '1105',      'TOK' ],
            ],
        // staff (monitor)
        12 => [ [ 'neuropower_bot', '1200',      'TOK' ],
              ],
    ];



    static protected function cmBots () { return self::$cmBots; }   // redefined from superclass

    private $cmt = null;

    public function __construct ()
    {
        $this->cmt = new ChatMediumTelegram();
    }

    public function getCMbotCredentialsByScriptName ($scriptName, $cmBots = null)
    {
        return $this->cmt->getCMbotCredentialsByScriptName($scriptName, self::$cmBots);
    }

    protected function getCMbotCredentialsByBBinfo ($bbCodename, $bbMajorVersionNumber, $bbBotName, $cmBots = null)
    {
        return $this->cmt->getCMbotCredentialsByBBinfo($bbCodename, $bbMajorVersionNumber, $bbBotName, self::$cmBots);
    }

    static public function getCMbotSpecialIndex ($anOldCMbotName)
    {
        foreach (self::$cmBots as $j => $credentials) {
            for ($i = 0; $i < count($credentials); $i++) { if ($credentials[$i][0] == $anOldCMbotName) { return [ $j, $i ]; } }
        }
        return null;
    }

    public function getCMbotNameBySpecialIndex ($idx)
    {
        return self::$cmBots[$idx[0]][$idx[1]];
    }

    /**
     * @param  $scriptName
     * @param  array
     * @return null|string
     */
    public function getAuthInfoForDownloadsByScriptName ($scriptName, $cmBots = null)
    {
        return $this->cmt->getAuthInfoForDownloadsByScriptName($scriptName, self::$cmBots);
    }

    // emulate a $_POST in $dressedUpdate as in WebRouterFake
    public function undressUpdate ($dressedUpdate, $cmAuthInfo, $textToPut = null, $userIdToPut = null)
    {
        $update    = json_decode(json_encode($dressedUpdate));
        $seqId     = $update->id;
        $chatId    = $update->chatId;
        $userid    = $update->userId;
        $username  = null;
        $userphone = null;
        $menuhook  = $update->menuhook == '' ? null : $update->menuhook;
        $text      = $menuhook === null ? $update->text : null;
        $u = Update::createByAttribs(ChatMedium::TYPE_CLISTUB, $seqId, $chatId, $userid, $username, $userphone, $text, $menuhook);
        return $u;
    }

    public function getDownloadUrl ($cmAuthInfo, $fileId)
    {
        return false;
    }

    public function dressSplash ($text, $menuOptions, $resource, $cmChannelOrCmChatInfo)
    {
        $res = [ $text, $menuOptions, $cmChannelOrCmChatInfo ];   // $resource is not used
        return $res;
    }

    public function display ($infoToPost)
    {
        list ($text, $menuOptions, $cmcOrChatInfo) = $infoToPost;   /** @var $cmcOrChatInfo ChatMediumChannel|array */
        $retval = true;
        // if $cmcOrChatInfo is not a cmChannel, this display is an error message when entering and display will be done synchronously
        if (! $cmcOrChatInfo instanceof ChatMediumChannel) {
            list ($cmBotName, $cmUserId, $cmChatId) = $cmcOrChatInfo;
            $request = $this->makeContentForPost($text, $menuOptions, $cmUserId, $cmChatId, $cmBotName);
        }
        // in normal cases the display will be done synchronously (output to standard output)
        else {
            $cmUserId  = $cmcOrChatInfo->getCMuserId();
            $cmChatId  = $cmcOrChatInfo->getCMchatInfo();
            $cmBotName = $cmcOrChatInfo->getCMbotName();
            $request   = $this->makeContentForPost($text, $menuOptions, $cmUserId, $cmChatId, $cmBotName);
        }
        // write output to standard output
        $res = $this->postToFile($request, self::$outFile);
        if (! $res) {
            // TODO Log this
            $retval = false;
        }
        // ready
        return $retval;
    }

    private function makeContentForPost ($text, $menuOptions, $cmUserId, $cmChatId, $cmBotName)
    {
        $msg  = "USER=" . ($cmUserId  === null ? "NULL" : $cmUserId ) . "\n";
        $msg .= "CHAT=" . ($cmChatId  === null ? "NULL" : $cmChatId ) . "\n";
        $msg .= "BOTN=" . ($cmBotName === null ? "NULL" : $cmBotName) . "\n";
        $msg .= "[" . ($text === null ? '' : $text) . "]";
        if ($menuOptions !== null) {
            $buttons = [];
            foreach ($menuOptions as $option) {
                list ($text, $callBack) = $option;   // TODO check how this is encoded inside each $option (copy from cmTelegram class)
                $buttons[] = "[$text/$callBack]";
            }
            $msg .= "\nMENU=" . join('', $buttons);
        }
        return $msg;
    }

    private function postToFile ($request, $filename)
    {
        $fn = $filename;
        $fh = fopen($fn, "a");
        if ($fh === false) {
            // TODO Log this
            return;
        }
        $res = fwrite($fh, "$request\n");
        if ($res === false) {
            // TODO Log this
        }
        fclose($fh);
    }

}

