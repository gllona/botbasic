<?php
/**
 * Medio de chat basado en el de Telegram donde la entrada viene de un formulario web y la salida va a un archivo en el servidor
 *
 * @author      Gorka G LLona                               <gorka@gmail.com> <gorka@venicua.com>
 * @license     http://www.venicua.com/botbasic/license     Licencia de BotBasic
 * @see         http://www.venicua.com/botbasic             Referencia de BotBasic
 * @version     1.0 - 01.jan.2017
 * @since       0.1 - 01.jul.2016
 */



namespace botbasic;



/**
 * Clase ChatMediumWebStub
 *
 * Subclase de ChatMedium que implementa la comunicación con la herramienta web de simulación de interacciones.
 *
 * @package botbasic
 */
class ChatMediumWebStub extends ChatMedium
{



    /** @var string Nombre del directorio en el que se reflejarán, como archivos, las salidas del simulador web de interacciones */
    static private $basedirForOutputFiles = "/home/gorka/telegram/panama_bot/fakechatmedium_outs";

    /** @var string|null Si no es null, este nombre de archivo recoge todas las salidas del simulador web, a efectos de bitácora concentrada */
    static private $superOutputFilename   = "ALL";

    /** @var array Mapa de bots definidos para esta chatapp, expresado como:
     *             [ bbCode-key-as-in-ChatMedium::$bbBots-for-default-bot    => [ botName, webHookScriptName, credential-for-chatapp-servers-API ],
     *               bbCode-key-as-in-ChatMedium::$bbBots-for-nondefault-bot => [...], ... ] */
    static private $cmBots = [
        // cliente
        10 => [ [ 'neuropowerbot',  'fake_10_00.php',      'TOK' ],
              ],
        // especialista channel 01 TO nn
        11 => [ [ 'np00bot',        'fake_11_00.php',      'TOK' ],
                [ 'np01bot',        'fake_11_01.php',      'TOK' ],
                [ 'np02bot',        'fake_11_02.php',      'TOK' ],
                [ 'np03bot',        'fake_11_03.php',      'TOK' ],
                [ 'np04bot',        'fake_11_04.php',      'TOK' ],
                [ 'np05bot',        'fake_11_05.php',      'TOK' ],
              ],
        // staff (monitor)
        12 => [ [ 'neuropower_bot', 'fake_12_00.php',      'TOK' ],
              ],
    ];

    /** @var ChatMediumTelegram La mayoría de los métodos se implementan llamando a los respectivos métodos de una instancia "artificial" de ChatMediumTelegram (patrón proxy) */
    private $cmt = null;



    static protected function cmBots () { return self::$cmBots; }   // redefined from superclass

    public function __construct ()
    {
        $this->cmt = new ChatMediumTelegram();
    }

    public function getCMbotCredentialsByScriptName ($scriptName, $cmBots = null)
    {
        return $this->cmt->getCMbotCredentialsByScriptName($scriptName, self::$cmBots);
    }

    protected function getCMbotCredentialsByBBinfo ($bbCodename, $bbMajorVersionNumber, $bbBotName, $cmBots = null)
    {
        return $this->cmt->getCMbotCredentialsByBBinfo($bbCodename, $bbMajorVersionNumber, $bbBotName, self::$cmBots);
    }

    static public function getCMbotSpecialIndex ($anOldCMbotName)
    {
        foreach (self::$cmBots as $j => $credentials) {
            for ($i = 0; $i < count($credentials); $i++) { if ($credentials[$i][0] == $anOldCMbotName) { return [ $j, $i ]; } }
        }
        return null;
    }

    public function getCMbotNameBySpecialIndex ($idx)
    {
        return self::$cmBots[$idx[0]][$idx[1]];
    }

    /**
     * @param  $scriptName
     * @param  array
     * @return null|string
     */
    public function getAuthInfoForDownloadsByScriptName ($scriptName, $cmBots = null)
    {
        return $this->cmt->getAuthInfoForDownloadsByScriptName($scriptName, self::$cmBots);
    }

    // pass $_POST to $dressedUpdate
    public function undressUpdate ($dressedUpdate, $cmAuthInfo, $textToPut = null, $userIdToPut = null)
    {
        $update    = json_decode(json_encode($dressedUpdate));
        $seqId     = $update->id;
        $chatId    = $update->chatId;
        $userid    = $update->userId;
        $username  = null;
        $userphone = null;
        $menuhook  = $update->menuhook == '' ? null : $update->menuhook;
        $text      = $menuhook === null ? $update->text : null;
        $u = Update::createByAttribs(ChatMedium::TYPE_WEBSTUB, $seqId, $chatId, $userid, $username, $userphone, $text, $menuhook);
        return $u;
    }

    public function getDownloadUrl ($cmAuthInfo, $fileId)
    {
        return false;
    }

    public function dressSplash ($text, $menuOptions, $resource, $cmChannelOrCmChatInfo)
    {
        $res = [ $text, $menuOptions, $cmChannelOrCmChatInfo ];   // $resource is not used
        return $res;
    }

    public function display ($infoToPost)
    {
        list ($text, $menuOptions, $cmcOrChatInfo) = $infoToPost;   /** @var $cmcOrChatInfo ChatMediumChannel|array */
        $retval = true;
        // if $cmcOrChatInfo is not a cmChannel, this display is an error message when entering and display will be done synchronously
        if (! $cmcOrChatInfo instanceof ChatMediumChannel) {
            list ($cmBotName, $cmUserId, $cmChatId) = $cmcOrChatInfo;
            $request = $this->makeContentForPost($text, $menuOptions, $cmUserId, $cmChatId, $cmBotName);
        }
        // in normal cases the display will be done synchronously (output to file)
        else {
            $cmUserId  = $cmcOrChatInfo->getCMuserId();
            $cmChatId  = $cmcOrChatInfo->getCMchatInfo();
            $cmBotName = $cmcOrChatInfo->getCMbotName();
            $request   = $this->makeContentForPost($text, $menuOptions, $cmUserId, $cmChatId, $cmBotName);
        }
        // write output to a local file
        $res = $this->postToFile($request, $cmBotName . "__" . $cmUserId);
        if (! $res) {
            // TODO Log this
            $retval = false;
        }
        // write output to a common, all-bots output file
        if (self::$superOutputFilename !== null) {
            $res = $this->postToFile($request, self::$superOutputFilename);
            if (! $res) {
                // TODO Log this
                $retval = false;
            }
        }
        // ready
        return $retval;
    }

    private function makeContentForPost ($text, $menuOptions, $cmUserId, $cmChatId, $cmBotName)
    {
        $msg  = "[";
        $msg .= "USER=" . ($cmUserId  === null ? "NULL" : $cmUserId ) . "|";
        $msg .= "CHAT=" . ($cmChatId  === null ? "NULL" : $cmChatId ) . "|";
        $msg .= "BOTN=" . ($cmBotName === null ? "NULL" : $cmBotName) . "|";
        $msg .= "] [" . ($text === null ? '' : $text) . "]";
        if ($menuOptions !== null) {
            $buttons = [];
            foreach ($menuOptions as $option) {
                list ($text, $callBack) = $option;   // TODO check how this is encoded inside each $option (copy from cmTelegram class)
                $buttons[] = "[$text/$callBack]";
            }
            $msg .= " [MENU=" . join('', $buttons) . "]";
        }
        return $msg;
    }

    private function postToFile ($request, $filename)
    {
        $fn = self::$basedirForOutputFiles . $filename;
        $fh = fopen($fn, "a");
        if ($fh === false) {
            // TODO Log this
            return;
        }
        $res = fwrite($fh, "$request\n");
        if ($res === false) {
            // TODO Log this
        }
        fclose($fh);
    }

}

