<?php
/**
 * Medio de chat que implementa la comunicación con la chatapp Telegram
 *
 * @author      Gorka G LLona                               <gorka@gmail.com> <gorka@venicua.com>
 * @license     http://www.venicua.com/botbasic/license     Licencia de BotBasic
 * @see         http://www.venicua.com/botbasic             Referencia de BotBasic
 * @version     1.0 - 01.jan.2017
 * @since       0.1 - 01.jul.2016
 */



namespace {
    require_once '../unirest/src/Unirest.php';
}



namespace botbasic {

    use \Unirest\Request;
    use \Unirest\Request\Body;



    /**
     * Clase ChatMediumTelegram
     *
     * Subclase de ChatMedium que implementa la comunicación con la chatapp Telegram, de la cual surgen las bases para el resto,
     * en términos del diseño inicial (BB v1.0) de la arquitectura de chatapps "pluggables".
     *
     * @package botbasic
     */
    class ChatMediumTelegram extends ChatMedium
    {



        /** @var array Mapa de bots definidos para esta chatapp, expresado como:
         *             [ bbCode-key-as-in-ChatMedium::$bbBots-for-default-bot    => [ botName, webHookScriptName, credential-for-chatapp-servers-API ],
         *               bbCode-key-as-in-ChatMedium::$bbBots-for-nondefault-bot => [...], ... ] */
        static private $cmBots = [
            // cliente
            10 => [ [ 'neuropowerbot',  'tgrp_10_00_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                  ],
            // especialista channel 01 TO nn
            11 => [ [ 'np00bot',        'tgrp_11_00_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                    [ 'np01bot',        'tgrp_11_01_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                    [ 'np02bot',        'tgrp_11_02_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                    [ 'np03bot',        'tgrp_11_03_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                    [ 'np04bot',        'tgrp_11_04_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                    [ 'np05bot',        'tgrp_11_05_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                  ],
            // staff (monitor)
            12 => [ [ 'neuropower_bot', 'tgrp_12_00_142857142857.php',      '12345678:JKHUHLGULGUIHOUHIOUHIUHUIOHUIHUIHJHHHJKH' ],
                  ],
        ];
        // TODO complete



        static protected function cmBots () { return self::$cmBots; }   // redefined from superclass

        static public function getCMbotNames ($cmType, $pattern = null)
        {
            $className = "ChatMedium" . self::typeString($cmType);   /** @var ChatMedium $className */
            $bots = $className::cmBots();
            $names = [];
            foreach ($bots as $idx => $someBots) {
                foreach ($someBots as $bot) {
                    if ($pattern !== null) { if (1 === preg_match($pattern, $bot[0])) { $names[] = $bot[0]; } }
                    else                   {                                            $names[] = $bot[0];   }
                }
            }
            return $names;
        }

        /**
         * @param  string   $scriptName
         * @param  array
         * @return string[] [ $bbCodeId, cmBotName, cmScriptName, cmBotTokenOrPassword ]
         */
        public function getCMbotCredentialsByScriptName ($scriptName, $cmBots = null)
        {
            if ($cmBots === null) { $cmBots = self::$cmBots; }
            if (($pos = strrpos($scriptName, '/')) !== false) { $scriptName = substr($scriptName, $pos + 1); }   // erase protocol://server:path/
            if (($pos = strpos( $scriptName, '?')) !== false) { $scriptName = substr($scriptName, 0, $pos);  }   // erase query string after the '?'
            foreach ($cmBots as $idx => $cmBotsPerBBbot) {
                foreach ($cmBotsPerBBbot as $cmBotCredentials) {
                    if ($cmBotCredentials[1] == $scriptName) { return array_merge([ $idx ], $cmBotCredentials); }
                }
            }
            return null;
        }

        /**
         * @param  string   $bbCodename
         * @param  string   $bbMajorVersionNumber
         * @param  string   $bbBotName
         * @param  array
         * @return string[] [ cmBotName, cmScriptName, cmBotTokenOrPassword ]
         */
        public function getCMbotCredentialsByBBinfo ($bbCodename, $bbMajorVersionNumber, $bbBotName, $cmBots = null)
        {
            if ($cmBots === null) { $cmBots = self::$cmBots; }
            $idx = $this->getBBbotIndexByBBinfo($bbCodename, $bbMajorVersionNumber, $bbBotName);
            return $cmBots[$idx];   // indexes in ChatMedium:$bbBots[] and in self:$cmBots[] are the same
        }

        static public function getCMbotSpecialIndex ($anOldCMbotName)
        {
            foreach (self::$cmBots as $j => $credentials) {
                for ($i = 0; $i < count($credentials); $i++) { if ($credentials[$i][0] == $anOldCMbotName) { return [ $j, $i ]; } }
            }
            return null;
        }

        public function getCMbotNameBySpecialIndex ($idx)
        {
            return self::$cmBots[$idx[0]][$idx[1]];
        }

        /**
         * @param  $scriptName
         * @param  array
         * @return null|string
         */
        public function getAuthInfoForDownloadsByScriptName ($scriptName, $cmBots = null)
        {
            $credentials = $this->getCMbotCredentialsByScriptName($scriptName, $cmBots);
            if ($credentials === null) { return null; }
            return $credentials[1];
        }

        //////////////
        // ENTER PHASE
        //////////////

        public function undressUpdate ($dressedUpdate, $cmAuthInfo, $textToPut = null, $userIdToPut = null)
        {
            $valid     = true;
            $resources = [];
            $update    = $dressedUpdate;
            $seqId     = $update->update_id;
            $chatId    = $update->chat_id;
            $text = $menuhook = $userid = $username = $userphone = null;
            // menuhooks
            if (isset($update->callback_query)) {
                $userid    = $update->callback_query->from->id;
                $username  = trim($update->callback_query->from->first_name . " " . $update->callback_query->from->last_name);
                $menuhook  = $update->callback_query->data;
            }
            // texts and resources
            elseif (isset($update->message)) {
                $userid    = $update->message->from->id;
                $username  = trim($update->message->from->first_name . " " . $update->message->from->last_name);
                if (isset($update->message->text)) { $text = $update->message->text; }
                if (isset($update->message->photo)) {
                    // choose the bigest image
                    $chosen = null; $chosenWidth = -1;
                    foreach ($update->message->photo as $photoSize) {
                        if ($chosen === null || $chosenWidth < $photoSize->width) { $chosen = $photoSize; }
                    }
                    $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_IMAGE, $cmAuthInfo, $update->message->audio->file_id);
                }
                if (isset($update->message->audio))    { $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_AUDIO,    $cmAuthInfo, $update->message->audio->file_id                                                             ); }
                if (isset($update->message->voice))    { $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_VOICE,    $cmAuthInfo, $update->message->voice->file_id                                                             ); }
                if (isset($update->message->video))    { $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_VIDEO,    $cmAuthInfo, $update->message->video->file_id                                                             ); }
                if (isset($update->message->document)) { $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_DOCUMENT, $cmAuthInfo, $update->message->document->file_id                                                          ); }
                if (isset($update->message->caption))  { $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_CAPTION,  $cmAuthInfo, $update->message->caption                                                                    ); }
                if (isset($update->message->location)) { $resources[] = InteractionResource::createFromFileId(InteractionResource::TYPE_LOCATION, $cmAuthInfo, [ $update->message->location->longitude, 'latitude' => $update->message->location->latitude ]); }
            }
            // invalid updates
            elseif (isset($update->edited_message)) {
                // TODO devolver una respuesta a la chatapp
                // * crear un update generico: "no son aceptados ediciones de mensajes ya enviados; copie y pegue"
                // * vestirlo de telegram
                // * enviarlo al router+sdk
                $valid = false;
            }
            else {
                // TODO idem como caso anterior con "operacion no permitida"
                $valid = false;
            }
            // make and return
            if (! $valid) { return null; }
            $u = Update::createByAttribs(ChatMedium::TYPE_TELEGRAM, $seqId, $chatId, $userid, $username, $userphone, $text, $menuhook);
            foreach ($resources as $resource) { $u->addResource($resource); }
            return $u;
        }

        public function getDownloadUrl ($cmAuthInfo, $fileId)
        {
            // obtain the bot name
            $cmBotName = $cmAuthInfo;
            if (! is_string($cmBotName)) { return null; }
            // obtain the bot token
            $cmBotToken = $this->getCMbotToken($cmBotName);
            if ($cmBotToken === null) {
                $this->conditionalLog("");   // TODO
                return false;
            }
            // assemble the request, post to Telegram and decode the answer
            $request = [ $cmBotName, json_decode('{ "file_id" : "' . $fileId . '" }'), "getFile" ];
            $info = $this->postToTelegram($request);
            if (! isset($info->file_path)) { return false; }
            else                           { return "https://api.telegram.org/file/bot" . $cmBotToken . "/" . $info->file_path; }
        }

        /////////////
        // EXIT PHASE
        /////////////

        public function dressSplash ($text, $menuOptions, $resource, $cmChannelOrCmChatInfo)
        {
            $res = [ $text, $menuOptions, $resource, $cmChannelOrCmChatInfo ];
            return $res;
        }

        public function display ($infoToPost)
        {
            list ($text, $menuOptions, $resource, $cmcOrChatInfo) = $infoToPost;   /** @var $cmcOrChatInfo ChatMediumChannel|array */
            // if $cmcOrChatInfo is not a cmChannel, this display is an error message when entering and display will be done synchronously
            if (! $cmcOrChatInfo instanceof ChatMediumChannel) {
                list ($cmBotName, , $cmChatId) = $cmcOrChatInfo;   // $cmUserId is unused because Telegram uses chat_id for binding
                $request = $this->makeContentForPost($text, null, null, $cmChatId, $cmBotName);
                $res = $this->postToTelegram($request);
                if (! $res) {
                    // TODO Log this
                    return false;
                }
            }
            // in normal cases the display will be done asynchronously
            else {
                $res = DBbroker::writeToTelegramMessageQueue($text, $menuOptions, $resource, $cmcOrChatInfo->getId());
                if ($res === null) {
                    // TODO Log this
                    return false;
                }
            }
            // ready
            return true;
        }

        //////////////////////////////////////////////
        // DAEMON ROUTINES
        // used when this file is invoked from the CLI
        //////////////////////////////////////////////

        private function conditionalLog ($content)
        {
            $lastLogTime = DBbroker::readLastlogtimeForMessageDaemon(ChatMedium::TYPE_TELEGRAM);   // unix time
            if ($lastLogTime === null) {
                // TODO Log this
            }
            $now = time();
            if ($now - $lastLogTime > BOTBASIC_MESSAGEDAEMON_MIN_SECS_TO_RELOG) {
                // TODO Log $content (intented function)
                DBbroker::writeCurrentLastlogtimeForMessageDaemon(ChatMedium::TYPE_TELEGRAM);
                if ($lastLogTime === null) {
                    // TODO Log this
                }
            }
        }

        private function unqueueStart ($tryCount)
        {
            $record = DBbroker::readFirstInTelegramMessageQueueAndMarkAsSending($tryCount);
            if ($record === null) {
                $this->conditionalLog([]);   // TODO "db error"
                return null;
            }
            return $record;   // can be false if no message must be sent
        }

        private function unqueueCommit ($id)
        {
            $res = DBbroker::markAsSentInTelegramMessageQueue($id);
            if ($res === null) {
                $this->conditionalLog([]);   // TODO "db error"
            }
        }

        private function unqueueRollback ($id)
        {
            $attempsCount = DBbroker::markAsUnsentInTelegramMessageQueue($id, BOTBASIC_MESSAGEDAEMON_MAX_SEND_ATTEMPTS);
            if ($attempsCount === null) {
                $this->conditionalLog([]);   // TODO "db error"
            }   // db error
            elseif ($attempsCount === false) {
                $this->conditionalLog([]);   // TODO id not found
            }
            elseif ($attempsCount < BOTBASIC_MESSAGEDAEMON_MAX_SEND_ATTEMPTS) {
                $this->conditionalLog([]);   // TODO "max send attemps for the message"
            }
        }

        // if $howMany == -1 this will not stop
        public function attemptToSend ($howMany, $interDelayMsecs)
        {
            $count = 0;
            while (true) {
                for ($tryCount = 0; $tryCount < BOTBASIC_MESSAGEDAEMON_MAX_SEND_ATTEMPTS; $tryCount++) {
                    $record = $this->unqueueStart($tryCount);
                    if ($record === null || $record === false) { return; }
                    list ($id, $text, $menuOptions, $resource, , $cmBotName, $cmChatId) = $record;   // $cmUserId is not used
                    $r = $this->makeContentForPost($text, $menuOptions, $resource, $cmChatId, $cmBotName);
                    $res = $this->postToTelegram($r);
                    if ($res === null) { $this->unqueueRollback($id); }
                    else               { $this->unqueueCommit(  $id); }
                    if ($howMany != -1 && ++$count > $howMany) { break 2; }
                    sleep($interDelayMsecs);
                }
            }
        }

        /**
         * @param $textOrCaption
         * @param $menuOptions
         * @param $resource         InteractionResource
         * @param $chatId
         * @param $cmBotName
         * @return array
         */
        private function makeContentForPost ($textOrCaption, $menuOptions, $resource, $chatId, $cmBotName)
        {
            if ($resource !== null) {
                switch ($resource) {
                    case InteractionResource::TYPE_IMAGE    : $method = "sendPhoto";    $content = $this->makePhotoContentBase($resource, $this->limitCaption($textOrCaption));       break;
                    case InteractionResource::TYPE_AUDIO    : $method = "sendAudio";    $content = $this->makeAudioContentBase($resource);                                            break;
                    case InteractionResource::TYPE_VOICE    : $method = "sendVoice";    $content = $this->makeVoiceContentBase($resource);                                            break;
                    case InteractionResource::TYPE_DOCUMENT : $method = "sendDocument"; $content = $this->makeDocumentContentBase($resource, $this->limitCaption($textOrCaption));    break;
                    case InteractionResource::TYPE_VIDEO    : $method = "sendVideo";    $content = $this->makeVideoContentBase($resource, $this->limitCaption($textOrCaption));       break;
                    case InteractionResource::TYPE_LOCATION : $method = "sendLocation"; $content = $this->makeLocationContentBase($resource);                                         break;
                    default                                 : $method = "sendText";     $content = $this->makeTextContentBase("invalid resource type in ChatMediumTelegram::makeJsonForPost()" . ($textOrCaption === null ? "" : " / $textOrCaption"));
                }
            }
            elseif ($textOrCaption !== null) {
                $method = "sendText";
                $content = $this->makeTextContentBase($textOrCaption, $menuOptions);
            }
            else {
                $method = "sendText";
                $content = $this->makeTextContentBase("neither text nor resource were passed in ChatMediumTelegram::makeJsonForPost()");
            }
            $content['chat_id'] = $chatId;
            return [ $cmBotName, $content, $method ];
        }

        private function limitCaption ($text)
        {
            $maxCaptionLength = 200;
            if (($len = strlen($text)) > $maxCaptionLength) {
                return substr($text, 0, $maxCaptionLength - 3) . "...";
            }
            return $text;
        }

        private function encodeTextForJsonHtml ($text)
        {
            // <>&
            $replacements = [ "<" => "&lt;", ">" => "&gt;", "&" => "&amp;" ];
            foreach ($replacements as $what => $for) { $text = str_replace($what, $for, $text); }
            // http://my.url/dot/com
            $text = preg_replace('/(https?):\/\/([^ ,.;\t\n]+)/', '<a href="$1://$2">$2</a>', $text);
            if ($text === null) {}   // TODO Log this (regexp error)
            // http:my-display-label://my.url/dot/com
            $text = preg_replace('/(https?):([^ \t\n:]+):\/\/([^ ,.;\t\n]+)/', '<a href="$1://$3">$2</a>', $text);
            if ($text === null) {}   // TODO Log this (regexp error)
            // ***bold-text***
            $text = preg_replace('/\*\*\*([^*\t\n])([^\t\n]*)\*\*\*/', '<bold>$1$2</bold>', $text);
            if ($text === null) {}   // TODO Log this (regexp error)
            // ___italic-text___
            $text = preg_replace('/___([^_\t\n])([^\t\n]*)___', '<i>$1$2</i>', $text);
            if ($text === null) {}   // TODO Log this (regexp error)
            // [[[preformatted-fixed-block-text]]] and newlines (avoids nesting of <pre>'s)
            $magicMarker = '!#"$#%$&%___!#"$#%$&%';
            $count = null;
            while ($count !== 0) {
                $text = preg_replace('/\[\[\[(.*)\n(.*)\]\]\]/', '[[[$1' . $magicMarker . '$2]]]', $text, 1, $count);
                if ($text === null) { break; }   // TODO Log this (regexp error) and then break
            }
            $text = preg_replace('/\[\[\[(.+)\]\]\]/', '<pre>$1</pre>', $text);
            if ($text === null) {}   // TODO Log this (regexp error)
            $text = str_replace("\n", "<pre>\n</pre>", $text);
            $text = str_replace($magicMarker, "\n", $text);
            // ready
            return $text;
        }

        private function makeTextContentBase ($text, $menuOptions = null)
        {
            $parameters = [
                'text'       => $this->encodeTextForJsonHtml($text),
                'parse_mode' => 'HTML',
            ];
            if ($menuOptions !== null) {
                $keyboard = [];
                $layout = $this->layoutMenuOptions($menuOptions);
                foreach ($layout as $layoutRow) {
                    $keybRow = [];
                    foreach ($layoutRow as $option) {
                        list ($text, $callBack) = $option;   // TODO check how this is encoded inside each $option
                        $button = [
                            'text'          => $text,
                            'callback_data' => $callBack,
                        ];
                        $keybRow[] = $button;
                    }
                    $keyboard[] = $keybRow;
                }
                $parameters['reply_markup'] = $keyboard;
            }
            return $parameters;
        }

        /**
         * @param $resource InteractionResource
         * @param $caption
         * @return array
         */
        private function makePhotoContentBase ($resource, $caption)
        {
            $parameters = [
                'photo'   => $resource->fileId,   // TODO en este momento solo se puede reenviar archivos por via de tuneles, no a partir de archivos en el servidor
                'caption' => $caption,
            ];
            return $parameters;
        }

        /**
         * @param $resource InteractionResource
         * @return array
         */
        private function makeAudioContentBase ($resource)
        {
            $parameters = [
                'audio' => $resource->fileId,
            ];
            return $parameters;
        }

        /**
         * @param $resource InteractionResource
         * @return array
         */
        private function makeVoiceContentBase ($resource)
        {
            $parameters = [
                'voice' => $resource->fileId,
            ];
            return $parameters;
        }

        /**
         * @param $resource InteractionResource
         * @param $caption
         * @return array
         */
        private function makeDocumentContentBase ($resource, $caption)
        {
            $parameters = [
                'document' => $resource->fileId,
                'caption'  => $caption,
            ];
            return $parameters;
        }

        /**
         * @param $resource InteractionResource
         * @param $caption
         * @return array
         */
        private function makeVideoContentBase ($resource, $caption)
        {
            $parameters = [
                'video' => $resource->fileId,
                'caption'  => $caption,
            ];
            return $parameters;
        }

        /**
         * @param $resource InteractionResource
         * @return array
         */
        private function makeLocationContentBase ($resource)
        {
            $parameters = [
                'longitude' => $resource->content['longitude'],   // TODO check: si esta es la estructura de datos donde se guarda el location
                'latitude'  => $resource->content['latitude'],
            ];
            return $parameters;
        }

        private function layoutMenuOptions ($menuOptions)
        {
            $maxTextLength = 0;
            foreach ($menuOptions as $option) {
                $text = $option[0];   // TODO check
                if (($len = strlen($text)) > $maxTextLength) { $maxTextLength = $len; }
            }
            $maxButtonsPerRow = floor(
                ( BOTBASIC_TELEGRAM_MAXPOSTWIDTH_PXS + BOTBASIC_TELEGRAM_EXTERNALPADDING_PXS )
                /
                ( 2*BOTBASIC_TELEGRAM_INTERNALPADDING_PXS + $maxTextLength*BOTBASIC_TELEGRAM_PXS_PER_CHAR + BOTBASIC_TELEGRAM_EXTERNALPADDING_PXS )
            );
            $layout = $row = [];
            for ($i = 0; $i < count($menuOptions);) {
                $row[] = $menuOptions[$i];
                if (++$i % $maxButtonsPerRow == 0) { $layout[] = $row; $row = []; }
            }
            if (count($row) != 0) { $layout[] = $row; }
            return $layout;
        }

        private function postToTelegram ($request)
        {
            list ($cmBotname, $content, $method) = $request;
            // obtain the bot token
            $token = $this->getCMbotToken($cmBotname);
            if ($token === null) {
                $this->conditionalLog("");   // TODO
                return false;
            }
            // assemble the url and determine the http header for the POST
            if ($method == "sendMessage" || $method == "getFile") {
                $accept = "application/json";
                $content = Body::Json($content);
            }
            else {
                $accept = "multipart/form-data";   // if a resource is sent with a custom keyboard, how to encode the custom keyboard into a form field? json? (doesn't apply to BotBasic)
            }
            $url = "https://api.telegram.org/bot$token/$method";
            // prepare and send
            $headers = array('Accept' => $accept);
            Request::timeout(BOTBASIC_MESSAGEDAEMON_POST_TIMEOUT_SECS);
            $response = Request::post($url, $headers, $content);
            // process HTTP response
            $isOk = substr($response->code, 0, 1) == "2";
            if (!$isOk) {
                // TODO conditional Log this: response_code
                return false;
            }
            // process telegram response
            $telegramResponse = $response->body;
            if ($method == "getFile") {
                if (! isset($telegramResponse->file_path)) { return false;                        }
                else                                       { return $telegramResponse->file_path; }
            }
            else {
                if (! isset($telegramResponse->ok)) {
                    // TODO conditional Log this: bad Telegram response (should have this field)
                    // see https://core.telegram.org/bots/api#making-requests
                    return false;
                }
                if ($telegramResponse->ok !== true) {
                    // TODO conditional Log this: ($telegramResponse->description) something went wrong
                    return false;
                }
                // all was ok
                return true;
            }
        }

        private function getCMbotToken ($cmBotname)
        {
            foreach (self::$cmBots as $id => $bots) {
                foreach ($bots as $bot) {
                    if ($bot[1] == $cmBotname) { return $bot[3]; }
                }
            }
            return null;
        }

    }



    ////////////////////////////////////////////////
    // DAEMON MAIN CODE (Apache-invoked)
    // see it in .../httpdocs/scripts/telegramsender
    ////////////////////////////////////////////////



}   // end of botbasic namespace

