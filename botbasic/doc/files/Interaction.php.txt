<?php
/**
 * Superclase para todas las interacciones entre sistema y usuario en ambos sentidos
 *
 * @author      Gorka G LLona                               <gorka@gmail.com> <gorka@venicua.com>
 * @license     http://www.venicua.com/botbasic/license     Licencia de BotBasic
 * @see         http://www.venicua.com/botbasic             Referencia de BotBasic
 * @version     1.0 - 01.jan.2017
 * @since       0.1 - 01.jul.2016
 */



namespace botbasic;



/**
 * Clase Interaction
 *
 * Superclase para Update (interacciones provenientes de la chatapp) y Update (interacciones provenientes del servidor de BotBasic).
 *
 * Las interacciones pueden tener asociados recursos (InteractionResource) que engloban a los contenidos multimedia.
 *
 * @package botbasic
 */
abstract class Interaction
{



    /** @const Tipo de Interaction en sentido chatapp hacia sistema ("update") */
    const TYPE_UPDATE = 101;

    /** @const Tipo de Interaction en sentido sistema hacia chatapp ("splash") */
    const TYPE_SPLASH = 102;

    /** @var null|int ID del Interaction, según como está en BD */
    protected $id       = null;

    /** @var int Tipo de Interaction (TYPE_...) */
    protected $type     = null;

    /** @var null|int ID del BotBasicChannel asociado */
    protected $bbcId    = null;

    /** @var null|int ID del BizModelUserId asociado al runtime que está asociado a este Interaction; este valor debe ser llenado a efectos
     *                de poder implementar business intelligence sólo por medio del análisis de la tabla interaction de la BD */
    protected $bmUserId = null;

    /** @var null|string Texto del Interaction (si hubiere); se refleja directamente y no como un Resource por su simplicidad y frecuencia */
    protected $text     = null;

    /** @var InteractionResource[] Recursos multimedia asociados a un Interaction */
    protected $resources = [];



    protected function __construct ($type)
    {
        $this->$type = $type;
    }

    static public function readFromDB ($id)
    {
        $data = DBbroker::readInteraction($id);
        if ($data === null)  {
            // TODO Log this
            return null;
        }
        elseif ($data === false) {
            // TODO Log this (ID not found)
            return null;
        }
        $type = $data[0];
        $interaction = Interaction::create($type);
        switch ($type) {
            case Interaction::TYPE_UPDATE :
                list (, $cmType, $cmSeqId, $cmChatInfo, $cmUserId, $cmUserName, $cmUserPhone, $bbcId, $bmUserId, $text, $menuhook) = $data;
                $interaction->fillFields([ $id, $cmType, $cmSeqId, $cmChatInfo, $cmUserId, $cmUserName, $cmUserPhone, $bbcId, $bmUserId, $text, $menuhook ]);
                break;
            case Interaction::TYPE_SPLASH :
                list (, $subType, $bbcId, $bmUserId, $text, $options) = $data;
                $interaction->fillFields([ $id, $subType, $bbcId, $bmUserId, $text, $options ]);
                break;
        }
        return $interaction;
    }

    abstract protected function fillFields ($values);

    public function writeToDB ()
    {
        $res = DBbroker::writeInteraction($this);
        if ($res === null) {
            // TODO Log this
            return null;
        }
        elseif ($res === false) {
            // TODO Log this: current non-(NULL|-1) ID not found in DB
            return null;
        }
        elseif ($res === true) {}                      // update done
        else                   { $this->id = $res; }   // insert done
        return true;
    }

    static protected function create ($type)
    {
        $i = null;
        if     ($type == self::TYPE_UPDATE) { $i = new Update(); }
        elseif ($type == self::TYPE_SPLASH) { $i = new Splash(); }
        return $i;
    }

    /**
     * iqwjhfiouheiojherio eioiog
     * oqierjfiojqeriofjqeiorfj
     * qeiorfjioerjfiojerfiojh
     *
     * @param  string           $key                        iuwdfh
     * @param  mixed            $value                      oiwejfoiujqeiofjqe
     * @param  null|string      $gotoOrGosub                qwehfuioqhefuiohqeriuh
     * @param  null|string      $gotoGosubTargetLineno      iuehdfuioyhaeuiyheuifh
     * @param  BotBasicChannel  $bbChannel                  oiqejrfiojq80rofuj
     * @param  int              $lineno                     oiwje0p{234¿ijpkrjoljk
     * @return null|string
     */
    static public function encodeMenuhook ($key, $value, $gotoOrGosub, $gotoGosubTargetLineno, $bbChannel, $lineno)   // $value is not currently encoded
    {
        self::doDummy($value);
        $data = DBbroker::createMenuhookSignature([ $key, $gotoOrGosub, $gotoGosubTargetLineno, $bbChannel->getId(), $lineno ]);   // $value is not stored in DB because it's not needed
        if ($data === null) { return null; }   // TODO log this
        list ($menuhookId, $signature) = $data;
        $encoded = "$menuhookId|$signature";
        return $encoded;
    }

    static public function decodeMenuhook ($encodedHookFromChatClient)
    {
        if ($encodedHookFromChatClient === null) { return null; }
        $parts = explode('|', $encodedHookFromChatClient);
        if (count($parts) != 2) { return null; }
        list ($menuhookId, $signature) = $parts;
        if (preg_match('/^[0-9]+$/', $menuhookId) !== 1) { return null; }
        $data = DBbroker::readMenuhookDataByIdAndSignature($menuhookId, $signature);
        if     ($data === null)  { return null; }   // TODO Log this
        elseif ($data === false) { return null; }   // TODO Log this: a forged menuhook click from a bad client
        return $data;   // [ key, value, lineno ]
    }

    public function setText ($text)      { $this->text = $text;     }   // use with care (currently only by event hooks re-shaping: "$eventword arg1 arg2 arg3...")

    public function getId   ()           { return $this->id;        }
    public function getType ()           { return $this->type;      }
    public function getBBchannelId ()    { return $this->bbcId;     }
    public function getBizModelUserId () { return $this->bmUserId;  }
    public function getText ()           { return $this->text;      }
    public function getResources ()      { return $this->resources; }

    public function hasResources ()      { return count($this->resources) > 0; }

    static private function doDummy ($arg) {}   // do nothing (this is for IDE spoofing)

}

